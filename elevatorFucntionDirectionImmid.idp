// First name: Ruben
// Last name: Kindt
// Student number: r0656495


// FIXED VOCABULARY
// DO NOT CHANGE THIS VOCABULARY
LTCvocabulary V_fixed {
    type Time isa nat			// A set of time points
    Start: Time 				// The initial time point
    partial Next(Time): Time 	// The successor time point of time point t
    
    type Floor isa nat									// The set of floors
    type DoorState constructed from {Closed, Open}		// A set of possible states of the elevator’s doors
	
    // Fluents
    ElPosition(Time):Floor				// The floor of the elevator at time point t
    ElDoorState(Time):DoorState			// The state of the elevator’s doors at time point t
    UnansweredRequest(Time, Floor)		// Denotes that there is an unanswered request at floor f at time point t
    
    // Actions
    MakeRequest(Time, Floor) 			// Denotes that a request is made for floor f at time point t
}


// STUDENT VOCABULARY
// Here you can add new types, functions and predicates
LTCvocabulary V_student {
    extern vocabulary V_fixed
    type Direction constructed from {up, down}
    //did not decide for a none direction, since it is not a direction and waiting should prevent moving in a direction and not be a direction itself
    //If none was a direction should not interfear with 
    	//only up<->down changes take a time unit
    		//none should not be added because it is not a 
    //fluents
    ElDirection(Time, Direction) // better than ElDirection(Time)=Direction because if will output one of the {up, down} while this is the set of {up, down} which can be the empty set aka waiting
    
    I_ElDirection(Direction)
    Cchange_ElDirection(Time, Direction)	//cause to change p113
    
    
    I_ElPosition(Floor)			// init floor position of the el
    Cchange_ElPos(Time, Floor)			// cause to position change
    CNchange_ElPos(Time, Floor)			// cause to position change
    
    
    I_UAnsweredRequest(Time, Floor)
    C_UAnsweredRequest(Time, Floor)
    CN_UAnsweredRequest(Time, Floor)
    
    waiting(Time)
	
    maxFloor: nat 
    reqBelow(Time)
    reqAbove(Time)
    closesReq(Time, Floor)
    
}

// TIME THEORY
// DO NOT CHANGE THIS THEORY
Theory T_fixed : V_student {
    // Defining time
    {
        Start = MIN[:Time].
        ! t: Next(t) = t+1 <- Time(t+1).
    }
}


// STUDENT THEORY
// Here you should model the dynamic elevator system
Theory T_student:V_student {
    maxFloor=MAX[:Floor].
    //? t[Time]: ElPosition(t)= ElPosition(Next(t)) & t<8.
    
    {
        ElPosition(Start)= 0.
        ! floor[Floor] t[Time]: 
        	ElPosition(Next(t)) = floor <- Cchange_ElPos(t, floor).
        ! floor[Floor] t[Time]: 
        	ElPosition(Next(t)) = floor <- ElPosition(t) = floor & ~CNchange_ElPos(t, floor) .
    }
    {
        ! floor[Floor] t[Time]: 
        	Cchange_ElPos(t, floor + 1) <- ElPosition(t) = floor & ElDirection(t, up).
        
        ! floor[Floor] t[Time]: 
        	Cchange_ElPos(t, floor - 1) <- ElPosition(t) = floor & ElDirection(t, down).
        
        
       /* ! floor[Floor] t[Time]: 
        	Cchange_ElPos(t, floor + 0) <- ElPosition(t) = floor & ElDirection(t) = none.
        */
        
        // cause not no change is wanneer er een verandering plaats vind
        ! t[Time] f[Floor] f2[Floor]: 
        	CNchange_ElPos(t, f) <- Cchange_ElPos(t, f2) & f ~= f2.
    }
    
   	{
        // there is a cause to change direction to up if we go where going up and UARequests above
        ! t[Time] currentFloor[Floor] f[Floor]: ElDirection(t, up) <- ElPosition(t)=currentFloor  & ~currentFloor = maxFloor &
        	reqAbove(t) & ((closesReq(t, f) & currentFloor=<f)).
        
        ! t[Time] f[Floor]: ElDirection(Next(t), up) <- ElDirection(t, up) & ~ElDirection(Next(t), down) &
        	reqAbove(t) & ~ElPosition(Next(t)) = maxFloor.
        //#{floor[Floor]: UnansweredRequest(Next(t), floor) & floor>ElPosition(Next(t))}>0 & ~ElPosition(Next(t)) = maxFloor.

        
        // je mag omlaag gaan als er nog request lager zijn.
        ! t[Time] : ElDirection(t, down) <- ~ElDirection(t, up) &
        	reqBelow(t) & ~ElPosition(t) = 0.

        ! t[Time] : ElDirection(Next(t), down) <- ElDirection(t, down) & ~ElDirection(Next(t), up) &
        	reqBelow(t) & ~ElPosition(Next(t))=0.

    }
    //!t[Time]: #{dir[Direction]: ElDirection(t, dir)} =<1.
    
    
    // there are request above/below
    !t[Time]: reqBelow(t) <=> #{floor[Floor]: UnansweredRequest(t, floor) & floor<ElPosition(t)}>0.
    !t[Time]: reqAbove(t) <=> #{floor[Floor]: UnansweredRequest(t, floor) & floor>ElPosition(t)}>0.
  
    
	// closest request part
    !t[Time] f[Floor] f2[Floor]: UnansweredRequest(t, f) & UnansweredRequest(t, f2) & f~=f2 &
    	abs(ElPosition(t)-f) = abs(ElPosition(t)-f2) & f>ElPosition(t) => closesReq(t, f).
    !t[Time] f[Floor] f2[Floor]: UnansweredRequest(t, f) & UnansweredRequest(t, f2) & f~=f2 &
    	abs(ElPosition(t)-f) < abs(ElPosition(t)-f2) => closesReq(t, f).
    !t[Time]: #{f[Floor]: UnansweredRequest(t, f)}>0 => #{f[Floor]: closesReq(t, f)}=1.
    !t[Time] f[Floor]: closesReq(t, f) => UnansweredRequest(t, f).
    

    // inertia Requests
    {
        ! floor[Floor] t[Time]: UnansweredRequest(t, floor) <- I_UAnsweredRequest(t,floor).
        //! floor[Floor] t[Time]: 
        //	UnansweredRequest(Next(t), floor) <- C_UAnsweredRequest(t, floor).
        ! floor[Floor] t[Time]: 
        	UnansweredRequest(Next(t), floor) <- UnansweredRequest(t, floor) & ~CN_UAnsweredRequest(t, floor).
    }
    {
        ! floor[Floor] t[Time]: I_UAnsweredRequest(t, floor) <- MakeRequest(t,floor).
        ! floor[Floor] t[Time]: CN_UAnsweredRequest(t, floor) <- ElPosition(t) = floor.
        
    }
    //! floor[Floor] t[Time]: CN_UAnsweredRequest(t, floor) <=> ElPosition(t) = floor.
	//! floor[Floor] t[Time]: UnansweredRequest(t, floor) <= MakeRequest(t,floor).
    
    
}


// MAIN PROCEDURE
// If you have to change the main procedure for debugging purposes, be careful and restore it back once you finish debugging.
procedure main() {
    local CompleteTheory = merge(T_fixed, T_student) 
           
    SS=S3
    
    model = onemodel(CompleteTheory, S1)
    if model == nil then
        print("S1 failed")
    else
        print("S1 succes")        
    end
    model = onemodel(CompleteTheory, S1b)
    if model == nil then
        print("S1b failed")
    else
        print("S1b succes")   
    end
	model = onemodel(CompleteTheory, S2)
    if model == nil then
        print("S2 failed")
    else
        print("S2 succes")   
    end
    
	model = onemodel(CompleteTheory, SS)
    if model == nil then
        print("curent ss failed")
        model = unsatstructure(CompleteTheory, SS)
    else 
        print("sucess")
    end
    
    print(model)
    // Visualization
    initVisualization()
    visualizeElevator(model)
}

/*
procedure minimumExplanation(partialS,consequence,rules) {
	negativeCons = makefalse(FalseStr) // negationofconsequence, use makefalseprocedure
	Sunsat = merge(partialS, negativeCons)
	return unsatstructure(rules, Sunsat)
}
procedure main( ) {
	consequences = optimalPropagate(Row3NoDouble5 , S )
	for consequence in consequences do
		minimumExplanation(S , consequence, Row3NoDouble5 )
	end
}
*/


// File responsible for visualization  
include "visualize_elevator.idp"

// Structures for testing
// You can open this file and check the given structures 
include "structures.idp"
